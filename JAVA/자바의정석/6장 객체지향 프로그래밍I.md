## 객체지향언어
* 객체지향언어의 주요특징
 1. 코드의 재사용성이 높다.
 2. 코드의 관리가 용이하다.
 3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
 - 재사용성, 유지보수, 중복된 코드의 제거

### 클래스와 객체
* 클래스는 '객체를 정의해놓은 것'이다.
* 클래스는 '객체를 생성하는데 사용'된다.
* 클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다.

### 객체와 인스턴스
* 클래스로부터 객체를 만드는 과정 = 클래스의 인스턴스화
* 클래스로부터 만들어진 객체     = 인스턴스

### 객체의 구성요소
* 객체는 '객체'와 '속성'으로 이루어져 있다.
* 속성 - 멤버변수, 특성, 필드, 상태
* 기능 - 메서드, 함수, 행위
 - 일반적으로 메서드보다는 멤버변수를 먼저 선언하고 멤버변수끼리, 메서드끼리 모아놓는다.

### 인스턴스의 생성과 사용
* 인스턴스는 참조변수를 통해서만 다룰 수 있으면, 참조 변수의 타입은 인스턴스의 타입과 일치해야한다.
* 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 '가비지 컬렉터'에 의해서 자동적으로 메모리에서 제거된다.
* 둘 이상의 참조변수가 하나의 인스턴스를 가리키는 것은 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리킬 순 없다.

### 객체 배열
* 객체 또한 배열로 다루는 것이 가능하다.
* 객체 자체가 아닌 객체의 주소가 저장된다.
* '다형성'을 배우고 나면 하나의 배열로 여러 종류의 객체를 다룰 수 있다.

### 프로그래밍적인 클래스의 정의
* 클래스 - 데이터와 함수의 결합
 1. 변수 - 하나의 데이터를 저장할 수 있는 공간
 2. 배열 - 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
 3. 구조체 - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
 4. 클래스 - 데이터와 함수의 결합(구조체 + 함수)
* String을 클래스로 정의한 이유
 - 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서.
 - 변수와 함수가 유기적으로 연결되어 작업이 간단하고 명료해진다.

### 변수 메서드
* static이 붙은것은 *클래스변수*, 붙지 않은것은 *인스턴스변수*이다.
* 메서드의 내부에서 선언되어 있는것은 *지역변수*
* 인스턴스변수
 - 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우 사용.
* 클래스변수
 - 모든 인스턴스가 공통된 저장공간을 공유하게 됨.
 - 인스턴스를 생성하지 않더라도 '클래스이름.클래스변수'의 형태로 사용 가능.
 - public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 *전역변수*가 된다.
* 지역변수
* 메서드 내에서만 사용 가능.
* 선언된 블럭{} 안에서만 사용이 가능하다.

### 메서드
* 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
* 메서드를 사용하는 이유
 1. 높은 재사용성
 2. 중복된 코드의 제거
 3. 프로그램 구조화

### 메서드 선언과 구현
* '선언부', '구현부'로 이루어져 있다.
* 반환타입 메서드이름 (매개변수선언)형태
* 매개변수 선언시 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다.
* 매개변수도 '지역변수'이다.
* 반환타입은 결과인 '반환값'의 타입을 적는다.
 - 반환값이 없는 경우 void를 사용한다.
* 반환타입이 'void'가 아닌경우, return 반환값;이 반드시 포함되어야한다.
 - 출력은 최대 하나만 허용함.
* 모든 메서드에는 적어도 하나의 return문이 있어야한다.
 - void의 경우는 컴파일러가 메서드의 마지막에 'return;'을 자동으로 추가해준다.
* 매개변수 유효성 검사는 필수!
* 기본형 매개변수는 기본형 값이 복사되지만 참조형 매개변수는 인스턴스의 주소가 복사된다.

### JVM 메모리 구조
* 메서드 영역
 - 클래스가 사용되면, 해당 클래스의 .class파일을 읽어 메서드영역에 저장한다.
* 힙
 - 인스턴스가 생성되는 공간. 프로그램 실행 중 모든 인스턴스가 이곳에 생성된다.
 - 즉, 인스턴스변수들이 생성되는 공간
* 호출스택
 - 메서드의 작업에 필요한 메모리 공간을 제공한다.
 - 메서드가 호출되면 호출스택에 메모리가 할당되고 작업을 마치면 메모리공간은 반환되어 비워진다.

### 재귀호출
* 메서드 내부에서 메서드 자신을 다시 호출하는 것을 '재귀호출'이라고 한다.
* 대부분의 재귀호출은 반복문으로 작성하는것이 가능하다.

### 클래스 메서드와 인스턴스 메서드
* 클래스 메서드도 클래스변수처럼, 객체를 생성하지 않고도 '클래스이름.메서드이름(매개변수)' 형식으로 호출할 수 있다.
* 클래스 영역에 선언된 변수를 *멤버변수*라고 한다. 인스턴스변수와 static변수를 통칭하는 말이다.
1. 클래스를 설계할 때, 멤버변수 중 *모든 인스턴스에 공통으로 사용하는 것*에 *static*을 붙인다.
2. 클래스 변수(static 변수)는 *인스턴스 변수를 생성하지 않아도* 사용할 수 있다.
3. 클래스 메서드는 인스턴스 변수를 *사용할 수 없다*.
4. 메서드 내에서 인스턴스 변수를 *사용하지 않는다면*, *static을 붙이는 것을 고려*한다.

### 클래스 멤버와 인스턴스 멤버간의 참조와 호출
* 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.
 - 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문.
* 인스턴스 멤버간의 호출에는 아무런 문제가 없다.
```java
MemberCall c = new MemberCall();
int result = c.instanceMethod();
// 위의 코드는 아래 코드로 바꿀 수 있다.
int result = new MemberCall().instanceMethod();
```

### 오버로딩
* 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 메서드가 있더라도 *매개변수의 개수 또는 타입이 다르면*,    
  같은 이름으로 메서드를 정의할 수 있다.
* 한 클래스 내에 같은 이름의 메서드를 여러개 정의하는 것을 '오버로딩(overloading)'이라 한다.

### 오버로딩 조건
1. 메서드 이름이 같아야한다.
2. 매개변수의 개수 또는 타입이 달라야한다.
- 반환타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.
- 서로 다른 타입의 매개변수 두개의 순서를 바꿔도 '오버로딩'으로 간주한다.

### 오버로딩의 장점
* 같은 기능의 메서드들이 하나의 이름으로 통일되어 이름만 보고도 '메서드의 기능'을 예측할 수 있다.
* 메서드의 이름을 절약할 수 있다.

### 가변인자(varargs)와 오버로딩
* 가변인자는 *타입... 변수명*과 같은 형식으로 선언한다.
 - 대표적인 예로는 PrintStream의 printf이다.
* 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 *제일 마지막에 선언*해야한다.
* 가변인자를 사용하면 인자의 개수를 가변적으로 할 수 있다. 인자가 없어도 되고 배열도 사용이 된다.
* 가변인자는 내부적으로 배열을 이용하는 것이기 떄문에 가변인자가 선언된 메서드를 호출할 때마다 *배열이 생성*된다.
* 가능하면 가변인자를 사용한 메서드는 *오버로딩하지 않는것*이 좋다.

### 생성자
* 인스턴스가 생성될 때 호출되는 *인스턴스 초기화 메서드*이다.
* 변수의 초기화 작업 & 인스턴스 생성 시 실행되어야 할 작업을 위해서 사용된다.
* 클래스 내에 선언되며 메서드와 구조가 유사하지만 리턴값이 없다.
* *생성자 이름은 클래스의 이름과 같아야한다.*
* 반드시 클래스 내에 정의된 생성자 중 하나를 지정해야한다.
```java
Card c = new Card();
```
1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.
2. *생성자 Card()* 가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.

### 기본생성자
* 사실 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다.
* *기본생성자(default constructor)* 를 컴파일러 제공하기 때문에 생성자를 정의하지 않아도 인스턴스 생성이 가능하다.

### 매개변수가 있는 생성자
* 인스턴스를 생성한 다음에 *인스턴스 변수의 값을 변경*하는 것보다 *매개변수를 갖는 생성자를 이용하는 것*이 좋다.

### 생성자에서 다른 생성자 호출하기
* 클래스 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.
 - 생성자의 이름으로 클래스이름 대신 *this*를 사용한다.
 - 한 생성자에서 다른 생성자를 호출할 때는 *반드시 첫 줄에서만 호출이 가능하다.*
* this - 인스턴스 *자신을 가리키는 참조변수, 인스턴스의 주소가 저장*되어 있다.    
         모든 인스턴스메서드에서 *지역변수로 숨겨진 채로 존재*한다.
* this(), this(매개변수) - *생성자*. 같은 클래스의 다른 생성자를 호출할 때 사용한다.

### 생성자를 이용한 인스턴스의 복사
```java
Car(Car c) {
    color = c.color;
    gearType = c.gearType;
    door = c.door;
}
```
* 참조변수를 매개변수로 선언한 생성자이다.
* 인스턴스의 상태를 몰라도 인스턴스를 추가로 생성할 수 있다.
* 서로 같은 상태를 갖지만 별도의 인스턴스이다.
* 인스턴스를 생성할때 2가지를 결정해야한다.
 1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
 2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

### 변수의 초기화
* 지역변수는 사용하기 전에 반드시 초기화해야한다.
 - 멤버변수(클래스변수와 인스턴스변수)와 배열의 초기화는 *선택적*이다.
* *명시적 초기화* - 변수를 *선언과 동시에 초기화*하는것.

### 초기화 블럭(initialization block)
* 클래스 초기화 블럭   클래스변수의 복잡합 초기화에 사용.
* 인스턴스 초기화 블럭  인스턴스변수의 복잡합 초기화에 사용.
* 사용하는 방법
 - 인스턴스 초기화는 클래스 내에 블럭{}을 만들고 그안에 코드를 작성.
 - 클래스 초기화는 블럭{} 앞에 static을 덧붙이면 된다.
* 조건문, 반복문, 예외처리구문 등을 자유롭게 사용할 수 있다.
* 클래스 초기화 블럭은 클래스가 *메모리에 처음 로딩될때 한번*만 수행된다.
* 인스턴스 초기화 블럭은 생성자와 같이 *인스턴스를 생성할 떄 마다* 수행된다.
* *생성자보다 인스턴스 초기화 블럭이 먼저 수행*된다.

### 멤버변수와 초기화 시기와 순서
* 클래스변수의 초기화시점 - 클래스가 처음 로딩될 때 단 한번 초기화 된다.
* 인스턴스변수의 초기화시점 - 인스턴스가 생성될때마다 각 인스턴스별로 초기화가 이루어진다.
* 클래스변수의 초기화순서 - 기본값->명시적초기화->클래스 초기화블럭
* 인스턴스변수의 초기화순서 - 기본값->명시적초기화->인스턴스 초기화블럭->생성자
